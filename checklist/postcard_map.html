<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Postcard Collection Map</title>
  <!-- Load Leaflet's CSS from a CDN -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-o9N1j7ZuKMYCGLMsvUf/H0V91jmNgtQ8hI+NdF+AvHU="
    crossorigin=""
  />
  <style>
    /* Make the map fill the entire viewport */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #map {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Load Leaflet's JavaScript from a CDN -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o9N1j7ZuKMYCGLMsvUf/H0V91jmNgtQ8hI+NdF+AvHU="
    crossorigin=""
  ></script>
  <script>
    // Immediately-invoked async function to set up the map and markers
    (async () => {
      // Initialize the map centred roughly on India
      const map = L.map('map').setView([22.5937, 78.9629], 5);

      // Add a dark-themed tile layer.  We use CARTO's Dark Matter tiles, which are free for
      // non-commercial use.  This provides a dark basemap that works well for coloured markers.
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attribution">CARTO</a>'
      }).addTo(map);

      // Define red and green marker icons using Google marker images
      const redIcon = L.icon({
        iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32]
      });
      const greenIcon = L.icon({
        iconUrl: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32]
      });

      // Fetch the postcard checklist data from a local JSON file.
      // The JSON file should reside in the same directory as this HTML file.
      const checklistResp = await fetch('checklist-data.json');
      const checklist = await checklistResp.json();

      // Build a list of unique pincodes to minimise the number of geocoding requests.
      const uniquePincodes = [...new Set(checklist.map(item => item.pincode))];

      // A cache to store the coordinates for each pincode once retrieved
      const coordsCache = {};

      // Helper function that queries an open geocoding service to convert a pincode
      // into latitude and longitude. It stores results in coordsCache to avoid
      // repeated lookups for the same pincode.
      async function geocodePincode(pin) {
        // If we've already looked up this pincode, return the stored result
        if (coordsCache[pin] !== undefined) {
          return coordsCache[pin];
        }
        try {
          // Use the free Zippopotam.us API to get coordinates for Indian pin codes.
          // This API does not require an API key and returns a list of places.  We
          // use the first place's latitude and longitude as the representative
          // coordinates for the pincode.
          const resp = await fetch(`https://api.zippopotam.us/IN/${pin}`);
          if (resp.ok) {
            const data = await resp.json();
            if (data && data.places && data.places.length > 0) {
              const place = data.places[0];
              const coords = {
                lat: parseFloat(place.latitude),
                lon: parseFloat(place.longitude)
              };
              coordsCache[pin] = coords;
              return coords;
            }
          }
        } catch (err) {
          console.error('Geocode lookup failed for pincode', pin, err);
        }
        coordsCache[pin] = null;
        return null;
      }

      // Sequentially geocode each unique pincode.  Doing this sequentially helps
      // avoid overwhelming the external service with too many simultaneous
      // requests.  If desired, this could be parallelised with care.
      for (const pin of uniquePincodes) {
        await geocodePincode(pin);
      }

      // Bounds array to determine the visible extent of all markers
      const bounds = [];

      // Now add a marker for every postcard entry using its pincode's coordinates
      for (const item of checklist) {
        const coords = coordsCache[item.pincode];
        if (!coords) {
          console.warn('Skipping marker due to missing coordinates for pincode', item.pincode);
          continue;
        }
        // Choose the marker icon colour based on the collected flag
        const chosenIcon = item.collected ? greenIcon : redIcon;
        const marker = L.marker([coords.lat, coords.lon], { icon: chosenIcon }).addTo(map);
        // Build a simple popup with the postcard's details
        const popup = `<strong>${item.name_of_ppc}</strong><br/>
          Pincode: ${item.pincode}<br/>
          Post Office: ${item.post_office}<br/>
          District: ${item.district}<br/>
          Collected: ${item.collected ? 'Yes' : 'No'}`;
        marker.bindPopup(popup);
        bounds.push([coords.lat, coords.lon]);
      }

      // If we have any markers, adjust the map view to fit them nicely
      if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [40, 40] });
      }
    })();
  </script>
</body>
</html>